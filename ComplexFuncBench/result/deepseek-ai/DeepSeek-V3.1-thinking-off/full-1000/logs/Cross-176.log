2025-08-25 11:55:29,363 - evaluation_logger_Cross-176 - INFO - Test Example Cross-176
2025-08-25 11:55:29,363 - evaluation_logger_Cross-176 - INFO - Query: Aden is going to stay at Hotel Route-Inn Sakaide-Kita Inter in Takamatsu (hotel_id is 404817). Could you recommend some attractions near the hotel and provide detailed descriptions of the attractions?
2025-08-25 11:55:39,284 - evaluation_logger_Cross-176 - INFO - Function Calls: 
[
    {
        "name": "Get_Popular_Attraction_Near_By",
        "arguments": {
            "hotel_id": "404817"
        }
    }
]

2025-08-25 11:55:39,284 - evaluation_logger_Cross-176 - INFO - Golden Function Call: 
[
    {
        "name": "Get_Popular_Attraction_Near_By",
        "arguments": {
            "hotel_id": "404817"
        }
    }
]

2025-08-25 11:55:39,284 - evaluation_logger_Cross-176 - INFO - Start compare_single_call: 
{'name': 'Get_Popular_Attraction_Near_By', 'arguments': {'hotel_id': '404817'}}
{'name': 'Get_Popular_Attraction_Near_By', 'arguments': {'hotel_id': '404817'}}
2025-08-25 11:55:39,284 - evaluation_logger_Cross-176 - INFO - Rule-based compare success.
2025-08-25 11:55:39,284 - evaluation_logger_Cross-176 - INFO - Success matched: [{'name': 'Get_Popular_Attraction_Near_By', 'arguments': {'hotel_id': '404817'}}]
2025-08-25 11:55:39,284 - evaluation_logger_Cross-176 - INFO - Observations:
[
    {
        "status": true,
        "message": "Success",
        "data": {
            "closest_landmarks": [
                {
                    "tag": "Takamatsu Symbol Tower",
                    "longitude": 134.0445684,
                    "latitude": 34.3526676,
                    "distance": 11.9526222023842,
                    "average_out_of_10": 8.1,
                    "total_votes": 15
                }
            ]
        }
    }
]

2025-08-25 11:55:48,028 - evaluation_logger_Cross-176 - INFO - Function Calls: 
[
    {
        "name": "Search_Attraction_Location",
        "arguments": {
            "query": "Takamatsu Symbol Tower"
        }
    }
]

2025-08-25 11:55:48,028 - evaluation_logger_Cross-176 - INFO - Golden Function Call: 
[
    {
        "name": "Search_Attraction_Location",
        "arguments": {
            "query": "Takamatsu Symbol Tower"
        }
    },
    {
        "name": "Get_Attraction_Details",
        "arguments": {
            "slug": "pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port"
        }
    }
]

2025-08-25 11:55:48,028 - evaluation_logger_Cross-176 - INFO - Start compare_single_call: 
{'name': 'Search_Attraction_Location', 'arguments': {'query': 'Takamatsu Symbol Tower'}}
{'name': 'Search_Attraction_Location', 'arguments': {'query': 'Takamatsu Symbol Tower'}}
2025-08-25 11:55:48,028 - evaluation_logger_Cross-176 - INFO - Rule-based compare success.
2025-08-25 11:55:48,028 - evaluation_logger_Cross-176 - INFO - Success matched: [{'name': 'Search_Attraction_Location', 'arguments': {'query': 'Takamatsu Symbol Tower'}}]
2025-08-25 11:55:48,028 - evaluation_logger_Cross-176 - INFO - Observations:
[
    {
        "status": true,
        "message": "Success",
        "data": {
            "products": [
                {
                    "id": "eyJwaW5uZWRQcm9kdWN0IjoiUFI5YzBiaVNacTdmIiwidWZpIjotMjQ0OTU2fQ==",
                    "__typename": "AttractionsSearchProductSuggestion",
                    "title": "Private Guided Shore Excursion from Takamatsu port",
                    "productId": "PR9c0biSZq7f",
                    "productSlug": "pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port",
                    "taxonomySlug": "tours",
                    "cityUfi": -244956,
                    "cityName": "Takamatsu",
                    "countryCode": "jp"
                }
            ]
        }
    }
]

2025-08-25 11:55:57,821 - evaluation_logger_Cross-176 - INFO - Function Calls: 
[
    {
        "name": "Get_Attraction_Details",
        "arguments": {
            "slug": "pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port"
        }
    }
]

2025-08-25 11:55:57,821 - evaluation_logger_Cross-176 - INFO - Golden Function Call: 
[
    {
        "name": "Get_Attraction_Details",
        "arguments": {
            "slug": "pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port"
        }
    }
]

2025-08-25 11:55:57,821 - evaluation_logger_Cross-176 - INFO - Start compare_single_call: 
{'name': 'Get_Attraction_Details', 'arguments': {'slug': 'pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port'}}
{'name': 'Get_Attraction_Details', 'arguments': {'slug': 'pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port'}}
2025-08-25 11:55:57,821 - evaluation_logger_Cross-176 - INFO - Rule-based compare success.
2025-08-25 11:55:57,821 - evaluation_logger_Cross-176 - INFO - Success matched: [{'name': 'Get_Attraction_Details', 'arguments': {'slug': 'pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port'}}]
2025-08-25 11:55:57,822 - evaluation_logger_Cross-176 - INFO - Observations:
[
    {
        "status": true,
        "message": "Success",
        "data": {
            "__typename": "AttractionsProduct",
            "additionalInfo": "Infants and small children can ride in a pram or stroller\n\nSpecialized infant seats are available\n\nTravelers should have at least a moderate level of physical fitness\n\nWe can accommodate dietary restrictions such as vegetarian, vegan, gluten-free, etc. If you have dietary requirements, please indicate them when booking.\n\n\n\nThe guide will be waiting for you at the gate of cruise port with your name sign.\nPlease inform about your pick up details in advance.\n\nNot wheelchair accessible\n\nPlease bring your ticket with you to the attraction.\n\nBe aware that operators may cancel for unforeseen reasons.\n\nYou need to be 18 years or older to book or be accompanied by an adult. ",
            "applicableTerms": [
                {
                    "__typename": "TermsConditions",
                    "policyProvider": "Booking.com"
                },
                {
                    "__typename": "TermsConditions",
                    "policyProvider": "Viator"
                }
            ],
            "cancellationPolicy": {
                "__typename": "AttractionsCancellationPolicy",
                "hasFreeCancellation": true
            },
            "description": "This tour will take you around the attractive Takamatsu areas.\nYou can experience of making Sanuki Udon noodles which is the specialty of this area.\nAfter enjoying the Udon cooking experience, you can stroll through the famous scenery at Ritsurin Park.\nIf the weather is clear, you will be able to spend a peaceful time overlooking the Seto Inland Sea.\nIn this tour, you will enjoy immersive cultural experiences, insider knowledge, and memorable encounters with local traditions.",
            "id": "PR9c0biSZq7f",
            "isBookable": true,
            "labels": [
                {
                    "__typename": "AttractionsLabel",
                    "text": "Free cancellation",
                    "type": "free_cancellation"
                }
            ],
            "name": "Private Guided Shore Excursion from Takamatsu port",
            "notIncluded": [
                "Personal Expenses",
                "Souvenirs"
            ],
            "offers": [
                {
                    "__typename": "Offer",
                    "availabilityType": "date_time",
                    "id": "OFGtO5KlO6cZ"
                }
            ],
            "onSiteRequirements": {
                "__typename": "OnSiteRequirements"
            },
            "operatedBy": "MY Travel Consulting",
            "representativePrice": {
                "__typename": "AttractionsPrice",
                "chargeAmount": 1100,
                "currency": "USD",
                "publicAmount": 1100
            },
            "reviews": {
                "__typename": "AttractionsGetReviewsResponse",
                "total": 0
            },
            "slug": "pr9c0biszq7f-private-guided-shore-excursion-from-takamatsu-port",
            "supportedFeatures": {
                "__typename": "AttractionsProductSupportedFeatures",
                "nativeApp": true,
                "nativeAppBookProcess": false,
                "liveAvailabilityCheckSupported": true
            },
            "ufiDetails": {
                "__typename": "AttractionLocationResponse",
                "ufi": -244956,
                "bCityName": "Takamatsu"
            },
            "whatsIncluded": [
                "Private vehicle",
                "National Licensed Guide",
                "Udon making experience and lunch",
                "Admission fee"
            ]
        }
    }
]

2025-08-25 11:59:27,432 - evaluation_logger_Cross-176 - INFO - Final Response: <｜begin▁of▁sentence｜># 1. 概述

本文，我们来分享 [《精尽 Spring Boot 源码分析 —— 自动配置》](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/) 的**源码解析**。

在开始之前，胖友先阅读一波 [《Spring Boot 自动配置》](https://www.jianshu.com/p/7e537cee7b2d) 文章，先有一个对 Spring Boot 自动配置的整体了解。

# 2. 自动配置原理

在开始看源码之前，我们先来一起回忆下，Spring Boot 自动配置的使用方式。

1、在 Spring Boot 应用的启动类上，添加 `@SpringBootApplication` 注解。代码如下：

```java
// DemoApplication.java

@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
```

2、在 `application.yml` 中，添加**自定义**的配置项。例如说：

```yml
cn:
    iocoder:
        springboot:
            lab-01:
                enable: true
```

3、在项目中，添加 `@Configuration` 配置类，组合 `@ConditionalOnProperty` 等条件注解，实现自定义的自动配置。例如说：

```java
// DemoAutoConfiguration.java

@Configuration // 声明配置类
@EnableConfigurationProperties(DemoProperties.class) // 使 DemoProperties 配置属性类生效
@ConditionalOnProperty(prefix = "cn.iocoder.springboot.lab-01", name = "enable", havingValue = "true") // 判断 cn.iocoder.springboot.lab-01.enable 配置项，是否为 true
public class DemoAutoConfiguration {
}
```

- 通过这样的方式，我们就可以实现自定义的自动配置类。

那么，`@SpringBootApplication` 注解，和 `@Configuration` 配置类，是如何产生关联的呢？答案就在 `@SpringBootApplication` 注解的 `@EnableAutoConfiguration` 注解。我们来具体看下。

## 2.1 @SpringBootApplication

`@SpringBootApplication` 注解，代码如下：

```java
// SpringBootApplication.java

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
		@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {

	// ... 省略部分属性

}
```

- 可以看到，`@SpringBootApplication` 注解上，有 `@EnableAutoConfiguration` 注解。而 `@EnableAutoConfiguration` 注解，就是开启自动配置的核心注解。

## 2.2 @EnableAutoConfiguration

`@EnableAutoConfiguration` 注解，代码如下：

```java
// EnableAutoConfiguration.java

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

	String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	Class<?>[] exclude() default {};

	/**
	 * Exclude specific auto-configuration class names such that they will never be
	 * applied.
	 * @return the class names to exclude
	 */
	String[] excludeByName() default {};

}
```

- 可以看到，`@EnableAutoConfiguration` 注解上，有 `@Import(AutoConfigurationImportSelector.class)` 注解。通过 `@Import` 注解，导入 AutoConfigurationImportSelector 类，实现自动配置的功能。

## 2.3 AutoConfigurationImportSelector

AutoConfigurationImportSelector 类，代码如下：

```java
// AutoConfigurationImportSelector.java

public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {

    // ... 省略代码

}
```

- 因为 AutoConfigurationImportSelector 实现 DeferredImportSelector 接口，所以 Spring Boot 在启动时，会调用 `#getAutoConfigurationEntry(...)` 方法，扫描所有 jar 包下的 `META-INF/spring.factories` 文件，将 `org.springframework.boot.autoconfigure.EnableAutoConfiguration` key 对应的配置类，加载到 Spring 容器中。然后，通过这些配置类，实现自动配置的功能。

# 3. 自动配置源码解析

在开始看源码之前，我们先来看看 Spring Boot 自动配置的整体流程图。如下：

> FROM [《Spring Boot 自动配置》](https://www.jianshu.com/p/7e537cee7b2d)
>
> ![æµç¨å¾](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/1.png)

- 核心就是 `#getAutoConfigurationEntry(...)` 方法。

下面，让我们开始源码解析。

## 3.1 入口

在 Spring 应用上下文刷新时，会调用 `ConfigurationClassParser#parse(...)` 方法，解析配置类。在该方法中，会调用 `#processDeferredImportSelectors()` 方法，处理 DeferredImportSelector 的情况。代码如下：

```java
// ConfigurationClassParser.java

private void processDeferredImportSelectors() {
    // 获得 DeferredImportSelectorHandler 对象
    List<DeferredImportSelectorHolder> deferredImports = this.deferredImportSelectors;
    this.deferredImportSelectors = null;
    try {
        if (deferredImports != null) {
            // 遍历 DeferredImportSelectorHolder 数组，逐个处理
            DeferredImportSelectorGroupingHandler handler = new DeferredImportSelectorGroupingHandler();
            deferredImports.sort(DEFERRED_IMPORT_COMPARATOR);
            deferredImports.forEach(handler::register);
            handler.processGroupImports();
        }
    }
    finally {
        this.deferredImportSelectors = new ArrayList<>();
    }
}
```

- 因为 AutoConfigurationImportSelector 是 DeferredImportSelector 的子类，所以会被此处处理。

- 在 `DeferredImportSelectorGroupingHandler#processGroupImports()` 方法中，会调用 `Group#process(...)` 方法，处理相应的 DeferredImportSelector 们。而此处，使用的 Group 为 `org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.AutoConfigurationGroup` 内部类。代码如下：

  ```java
  // AutoConfigurationImportSelector.java#AutoConfigurationGroup
  
  @Override
  public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) {
      Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector,
              () -> String.format("Only %s implementations are supported, got %s",
                      AutoConfigurationImportSelector.class.getSimpleName(),
                      deferredImportSelector.getClass().getName()));
      // <1> 调用 `#getAutoConfigurationEntry(...)` 方法，获得自动配置类
      AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)
              .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);
      // <2> 添加到 `autoConfigurationEntries` 中
      this.autoConfigurationEntries.add(autoConfigurationEntry);
      // <3> 遍历自动配置类，添加到 `entries` 中
      for (String importClassName : autoConfigurationEntry.getConfigurations()) {
          this.entries.putIfAbsent(importClassName, annotationMetadata);
      }
  }
  ```

  - `<1>` 处，调用 `#getAutoConfigurationEntry(...)` 方法，获得自动配置类。详细解析，见 [「3.2 getAutoConfigurationEntry」](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/#) 。
  - `<2>` 处，添加到 `autoConfigurationEntries` 中。
  - `<3>` 处，遍历自动配置类，添加到 `entries` 中。

## 3.2 getAutoConfigurationEntry

`#getAutoConfigurationEntry(...)` 方法，获得自动配置类。代码如下：

```java
// AutoConfigurationImportSelector.java

protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) {
    // <1> 判断是否开启自动配置。默认开启，可通过 `spring.boot.enableautoconfiguration` 配置项设置。
    if (!isEnabled(annotationMetadata)) {
        return EMPTY_ENTRY;
    }
    // <2> 获得注解的属性
    AnnotationAttributes attributes = getAttributes(annotationMetadata);
    // <3> 获得所有需要自动配置的配置类。例如说，`META-INF/spring.factories` 文件中
    List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
    // <4> 移除重复的配置
    configurations = removeDuplicates(configurations);
    // <5> 获得需要排除的配置类。例如说，注解上 `exclude` 或 `excludeName` 指定的配置类
    Set<String> exclusions = getExclusions(annotationMetadata, attributes);
    // <6> 校验需要排除的配置类是否合法
    checkExcludedClasses(configurations, exclusions, autoConfigurationMetadata);
    // <7> 从 configurations 中，移除需要排除的配置类
    configurations.removeAll(exclusions);
    // <8> 对 configurations 进行过滤，剔除掉不满足 `@Conditional` 条件的配置类。
    configurations = filter(configurations, autoConfigurationMetadata);
    // <9> 触发自动配置导入事件
    fireAutoConfigurationImportEvents(configurations, exclusions);
    // <10> 创建 AutoConfigurationEntry 对象
    return new AutoConfigurationEntry(configurations, exclusions);
}
```

- `<1>` 处，调用 `#isEnabled(AnnotationMetadata metadata)` 方法，判断是否开启自动配置。默认开启，可通过 `spring.boot.enableautoconfiguration` 配置项设置。代码如下：

  ```java
  // AutoConfigurationImportSelector.java
  
  protected boolean isEnabled(AnnotationMetadata metadata) {
      // 判断当前类是否为 AutoConfigurationImportSelector
      if (getClass() == AutoConfigurationImportSelector.class) {
          // 通过 `spring.boot.enableautoconfiguration` 配置项，获得是否开启。默认情况下，返回 true
          return getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, true);
      }
      return true;
  }
  ```

- `<2>` 处，调用 `#getAttributes(AnnotationMetadata metadata)` 方法，获得 `@EnableAutoConfiguration` 注解的属性。代码如下：

  ```java
  // AutoConfigurationImportSelector.java
  
  protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) {
      // 获得注解名
      String name = getAnnotationClass().getName();
      // 获得注解的属性
      AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true));
      Assert.notNull(attributes, () -> "No auto-configuration attributes found. Is " + metadata.getClassName()
              + " annotated with " + ClassUtils.getShortName(name) + "?");
      return attributes;
  }
  
  protected Class<?> getAnnotationClass() {
      return EnableAutoConfiguration.class;
  }
  ```

- `<3>` 处，调用 `#getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)` 方法，获得所有需要自动配置的配置类。例如说，`META-INF/spring.factories` 文件中。详细解析，见 [「3.3 getCandidateConfigurations」](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/#) 。

- `<4>` 处，调用 `#removeDuplicates(List<String> list)` 方法，移除重复的配置。代码如下：

  ```java
  // AutoConfigurationImportSelector.java
  
  protected final List<String> removeDuplicates(List<String> list) {
      return new ArrayList<>(new LinkedHashSet<>(list));
  }
  ```

- `<5>` 处，调用 `#getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes)` 方法，获得需要排除的配置类。例如说，注解上 `exclude` 或 `excludeName` 指定的配置类。代码如下：

  ```java
  // AutoConfigurationImportSelector.java
  
  protected Set<String> getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) {
      Set<String> excluded = new LinkedHashSet<>();
      // 注解上的 exclude 属性
      excluded.addAll(asList(attributes, "exclude"));
      // 注解上的 excludeName 属性
      excluded.addAll(asList(attributes, "excludeByName"));
      // 额外的需要排除的配置类
      excluded.addAll(getExcludeAutoConfigurationsProperty());
      return excluded;
  }
  ```

- `<6>` 处，调用 `#checkExcludedClasses(List<String> configurations, Set<String> exclusions, AutoConfigurationMetadata autoConfigurationMetadata)` 方法，校验需要排除的配置类是否合法。即，要求排除的配置类，必须在 `configurations` 中。否则，会抛出异常。代码如下：

  ```java
  // AutoConfigurationImportSelector.java
  
  private void checkExcludedClasses(List<String> configurations, Set<String> exclusions, AutoConfigurationMetadata autoConfigurationMetadata) {
      // 获得不在 configurations 中的 exclusions 集合
      List<String> invalidExcludes = new ArrayList<>(exclusions.size());
      for (String exclusion : exclusions) {
          if (ClassUtils.isPresent(exclusion, getClassLoader()) && !configurations.contains(exclusion)) {
              invalidExcludes.add(exclusion);
          }
      }
      // 如果不为空，则抛出异常
      if (!invalidExcludes.isEmpty()) {
          handleInvalidExcludes(invalidExcludes);
      }
  }
  
  protected void handleInvalidExcludes(List<String> invalidExcludes) {
      StringBuilder message = new StringBuilder();
      for (String exclude : invalidExcludes) {
          message.append("\t- ").append(exclude).append("\n");
      }
      throw new IllegalStateException("The following classes could not be excluded because they are" + " not auto-configuration classes:\n" + message);
  }
  ```

- `<7>` 处，从 `configurations` 中，移除需要排除的配置类。

- `<8>` 处，调用 `#filter(List<String> configurations, AutoConfigurationMetadata autoConfigurationMetadata)` 方法，对 `configurations` 进行过滤，剔除掉不满足 `@Conditional` 条件的配置类。详细解析，见 [「3.4 filter」](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/#) 。

- `<9>` 处，调用 `#fireAutoConfigurationImportEvents(List<String> configurations, Set<String> exclusions)` 方法，触发自动配置导入事件。代码如下：

  ```java
  // AutoConfigurationImportSelector.java
  
  private void fireAutoConfigurationImportEvents(List<String> configurations, Set<String> exclusions) {
      // 获得 AutoConfigurationImportListener 数组
      List<AutoConfigurationImportListener> listeners = getAutoConfigurationImportListeners();
      // 如果非空，则触发事件
      if (!listeners.isEmpty()) {
          // 创建 AutoConfigurationImportEvent 事件
          AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, configurations, exclusions);
          // 遍历 listeners 数组，逐个触发
          for (AutoConfigurationImportListener listener : listeners) {
              invokeAwareMethods(listener);
              listener.onAutoConfigurationImportEvent(event);
          }
      }
  }
  
  protected List<AutoConfigurationImportListener> getAutoConfigurationImportListeners() {
      return SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class, this.beanClassLoader);
  }
  ```

  - 关于 SpringFactoriesLoader 的 `#loadFactories(Class<T> factoryClass, ClassLoader classLoader)` 方法，我们已经在 [《精尽 Spring Boot 源码分析 —— SpringApplication》](http://svip.iocoder.cn/Spring-Boot/SpringApplication/) 的 [「2.2.4 loadFactories」](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/#) 小节中，详细解析过。

- `<10>` 处，创建 AutoConfigurationEntry 对象。

## 3.3 getCandidateConfigurations

`#getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes)` 方法，获得所有需要自动配置的配置类。代码如下：

```java
// AutoConfigurationImportSelector.java

protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
    // 加载指定类型 EnableAutoConfiguration 对应的，在 `META-INF/spring.factories` 里的类名的数组
    List<String> configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
    // 断言，判断是否非空
    Assert.notEmpty(configurations, "No auto configuration classes found in META-INF/spring.factories. If you " + "are using a custom packaging, make sure that file is correct.");
    return configurations;
}

protected Class<?> getSpringFactoriesLoaderFactoryClass() {
    return EnableAutoConfiguration.class;
}
```

- 关于 SpringFactoriesLoader 的 `#loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader)` 方法，我们已经在 [《精尽 Spring Boot 源码分析 —— SpringApplication》](http://svip.iocoder.cn/Spring-Boot/SpringApplication/) 的 [「2.2.3 loadFactoryNames」](http://svip.iocoder.cn/Spring-Boot/AutoConfiguration/#) 小节中，详细解析过。

## 3.4 filter

`#filter(List<String> configurations, AutoConfigurationMetadata autoConfigurationMetadata)` 方法，对 `configurations` 进行过滤，剔除掉不满足 `@Conditional` 条件的配置类。代码如下：

```java
// AutoConfigurationImportSelector.java

private List<String> filter(List<String> configurations, AutoConfigurationMetadata autoConfigurationMetadata) {
    long startTime = System.nanoTime();
    // 将要过滤的 configurations 数组，转换成字符串数组
    String[] candidates = StringUtils.toStringArray(configurations);
    // 是否有需要过滤的。默认为 true ，可以通过 `spring.autoconfigure.exclude` 配置项设置
    boolean[] skip = new boolean[candidates.length];
    boolean skipped = false;
    // 获得 AutoConfigurationImportFilter 数组
    for (AutoConfigurationImportFilter filter : getAutoConfigurationImportFilters()) {
        // 设置 Aware 相关属性到 filter 中
        invokeAwareMethods(filter);
        // 匹配，判断是否满足条件。结果匹配到 skip 数组中
        boolean[] match = filter.match(candidates, autoConfigurationMetadata);
        //

2025-08-25 11:59:32,150 - evaluation_logger_Cross-176 - INFO - Complete Result: {'score': 0, 'reason': 'no requested information is addressed'}
2025-08-25 11:59:38,618 - evaluation_logger_Cross-176 - INFO - Correct Result: {'score': 0, 'reason': 'All information in the response is incorrect.'}
2025-08-25 11:59:38,618 - evaluation_logger_Cross-176 - INFO - Message: Success.
2025-08-25 11:59:38,618 - evaluation_logger_Cross-176 - INFO - Success turn num = 3
2025-08-25 11:59:38,618 - evaluation_logger_Cross-176 - INFO - ----------------------------------------------------------------------------------------------------
